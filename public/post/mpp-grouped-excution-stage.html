<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="google-site-verification" content="KEatQX-J4dYY-6J2KU_aP5X8gAJ8wS0lhylI8umX6WA" />
    <meta name="viewport" content="width=device-width,initial-scale=1,minimal-ui">
    <link rel="shortcut icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../css/code.css" type="text/css"/>
    <link rel="stylesheet" href="../css/bootstrap.css" type="text/css"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css"/>
    <title>编程小梦|MPP Pipeline VS Grouped Execution VS Stage By Stage</title>
</head>
<body>
<nav class="navbar navbar-default navbar-static-top" style="opacity: .9" role="navigation">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">编程小梦</a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li><a href="https://perf.bcmeng.com/" target="_blank"  rel="nofollow">《OLAP 数据库性能优化指南》</a></li>
                <li class="active"><a href="/">Blog</a></li>
            </ul>
        </div>
    </div>
</nav>
<div class="row" style="padding-top: 60px">
    <div class="container center-block">
        <div class="col-md-1"></div>
        <div class="col-md-10 col-sm-12">
            <h1> MPP Pipeline VS Grouped Execution VS Stage By Stage</h1>
            <hr/>
            <p>作者: 康凯森</p>
            <p>日期: 2023-04-08</p>
            <p>分类: <a href="../tag/OLAP.html" target="_blank" >OLAP</a></p>
            <hr/>
            <!-- toc -->
<ul>
<li><a href="#what-is-in-mpp-pipeline">What Is In MPP Pipeline</a></li>
<li><a href="#what-is-grouped-execution">What Is Grouped Execution</a></li>
<li><a href="#what-is-stage-by-stage">What Is Stage By Stage</a></li>
<li><a href="#mpp-pipeline-vs-stage-by-stage">MPP Pipeline VS Stage By Stage</a></li>
<li><a href="#grouped-execution-vs-stage-by-stage">Grouped Execution VS Stage By Stage</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- toc stop -->
<p>Presto 最近发布了新的论文，<a href="https://research.facebook.com/publications/presto-a-decade-of-sql-analytics-at-meta/">Presto: A Decade of SQL Analytics at Meta</a> 刚好 Presto 同时支持了 MPP Pipeline , Grouped Execution, Stage By Stage 3 种分布式执行模式，就想把这3种执行模式对比下。</p>
<h2 id="what-is-in-mpp-pipeline">What Is In MPP Pipeline</h2>
<p><img src="media/16809257712677/16809304004199.jpg" alt="MPP vs spark"></p>
<p><img src="media/16809257712677/16809304667938.jpg" alt="mpp 1"></p>
<p>如图所示，本文特指以 StarRocks,Presto 为代表的 MPP 查询引擎，具有以下特点：</p>
<ol>
<li>整个分布式执行是全部 In Memory 的</li>
<li>整个分布式执行是 Pipeline 的，每个 Fragment 会 Streaming 的传输数据给下一个 Fragment，不需要一个 Fragment 处理完所有数据再传输给下一个 Fragment</li>
<li>支持 Shuffle， Shuffle 是 In Memory 和 Streaming 的</li>
</ol>
<h2 id="what-is-grouped-execution">What Is Grouped Execution</h2>
<p><img src="media/16809257712677/colocate%20join.png" alt="colocate join"></p>
<p>Grouped Execution 其实很好理解，大家可以从 Colocate join 来理解，如上图，T1 和 T2 两张表的数据在导入时已经按照 Id 列分桶，所以相同的 Id 的数据都在一台节点上，Join 时就不需要重新 shuffle，但还有一个重要的点是：<strong>每个分桶的 Join 执行完成后就可以直接返回 Join 的最终结果，所以当我们内存不足时，我们就不需要所有节点或者分桶上面的 Join 同时启动，我们可以按照一个分桶一个分桶依次执行 Join 操作</strong>，这样我们需要内存的资源就会减少几十倍，同时也可以按照分桶粒度进行重试和容错，这就是 Grouped Execution 的核心原理。</p>
<p>那如果两张表的数据没有提前按照 Join 的 Column 分桶呢？答案很简单，如下图所示，和我们查询时处理 Shuffle Join 一样，额外 Shuffle 一次就行，并将 Shuffle 的结果持久化下来，然后过程就和上面介绍的 Colocate 处理的流程一样了。</p>
<p><img src="media/16809257712677/group%20execution.png" alt="group execution"></p>
<h2 id="what-is-stage-by-stage">What Is Stage By Stage</h2>
<p><img src="media/16809257712677/16809304004199.jpg" alt="MPP vs spark"></p>
<p><img src="media/16809257712677/16809304917832.jpg" alt=""></p>
<p>如图所示，本文特指以 MapReduce, Spark 为代表的批处理引擎，具有以下特点：</p>
<ol>
<li>整个分布式执行是 Stage By Stage 的，每个 Stage 会落盘</li>
<li>Shuffle 需要落盘</li>
</ol>
<h2 id="mpp-pipeline-vs-stage-by-stage">MPP Pipeline VS Stage By Stage</h2>
<p><strong>1 端到端的延迟：</strong></p>
<p>以 StarRocks 和 Presto 为代表的 MPP 查询引擎，端到端延迟更低，因为每个 Fragment 有数据就会立即发送给下游，用户接受到第一条数据的时间更短。</p>
<p><strong>2 容错或者批处理能力：</strong></p>
<p>以 Spark 为代表的 Stage By Stage 的执行模式容错能力更好， 因为在每个 Stage 执行结束时是一个 物化点或者 Checkpoint 点，失败后可以从上一个 Stage 恢复，但是 MPP Pipeline 执行模式一旦失败，就需要整个查询重新执行，所以不适合执行 ETL 类执行时间很长的SQL。</p>
<p><strong>3 内存使用：</strong></p>
<p>MPP Pipeline 对于复杂查询需要的内存可能更多，因为 Stage By Stage 模式每个 Stage 执行结束后，就可以立即释放内存，但是 MPP Pipeline 模式可能需要在多个 Fragment 中保留多个 Hash 表（Hash Join 和 Hash Aggregate），只有整个查询执行结束，这些 Hash 表 才可以一起释放。</p>
<p><strong>4 调度方式：</strong></p>
<p>StarRocks 和 Presto 是 All At Once 的调度，整个查询所有 Fragment 需要全部就绪，但是 Spark 是 Stage By Stage 的，任务是按照 Stage 逐批启动的。 （注： Presto 也支持 phased 调度方式，优化了这一点）</p>
<p><strong>5 可扩展性：</strong></p>
<p>StarRocks 和 Presto In Memory Shuffle 的方式在几百上千节点的时候，可能会受到内存，连接数等资源的限制</p>
<p><strong>6 自适应执行：</strong></p>
<p>Spark Stage By Stage 的执行方式更容易在每个 Stage 结束后收集统计信息，重新规划 Plan， MPP pipeline 模式自适应的难度更大一些</p>
<p><strong>7 慢节点问题：</strong></p>
<p>依靠推测执行和容错，Spark 的Stage By Stage 执行方式可以相对更好的处理慢节点问题。</p>
<h2 id="grouped-execution-vs-stage-by-stage">Grouped Execution VS Stage By Stage</h2>
<p>因为 Grouped Execution 和 Stage By Stage 都是想解决 ETL 执行的问题，所以我们对比主要集中在 ETL 相关的点。</p>
<p><strong>1 容错粒度：</strong></p>
<p>Grouped Execution 容错的粒度比较粗，必须以 Shuffle 为容错点，而 Spark 可以以任意的 Mapper 和 Reducer 为容错点，查询重试的粒度更细，并且 Mapper 和 Reducer 可以独立调度和重试</p>
<p>Grouped Execution 不能容忍节点粒度的 Crash，但是 Spark 可以</p>
<p><strong>2 隔离级别：</strong></p>
<p>Grouped Execution 的隔离粒度是节点级别， Spark 是 Container 级别, 粒度更细 </p>
<p><strong>3 可扩展性和稳定性：</strong></p>
<p>Grouped Execution 依然是 In Memory 的 Shuffle， 稳定性不如 Spark 的 Shuffle Service。</p>
<p>由于 Grouped Execution 的上述缺陷，Presto 发起了 Presto on Spark 项目，并逐步代替了 Grouped Execution，也宣告了 Grouped Execution 这个项目的失败。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>Presto 2018 论文: <a href="https://trino.io/Presto_SQL_on_Everything.pdf">Presto: SQL on Everything</a></li>
<li>Presto 2023 论文: <a href="https://research.facebook.com/publications/presto-a-decade-of-sql-analytics-at-meta/">Presto: A Decade of SQL Analytics at Meta</a></li>
<li><a href="https://prestodb.io/blog/2019/08/05/presto-unlimited-mpp-database-at-scale">Presto Unlimited: MPP SQL Engine at Scale</a></li>
<li><a href="https://prestodb.io/blog/2021/10/26/Scaling-with-Presto-on-Spark">Scaling with Presto on Spark</a></li>
</ul>

            <hr/>
            <h3>《OLAP 性能优化指南》欢迎 Star&共建 </h3>
            <p><a href="https://github.com/kangkaisen/olap-performance" target="_blank" >《OLAP 性能优化指南》</a></p>
            <h3>欢迎关注微信公众号</h3>
            <div style="padding: 0; margin: 10px auto; width: 90%; text-align: center"><p><img src="../images/zhishixingqiu.png" /></p></div>
        </div>
        <div class="col-md-1"></div>
    </div>
</div>

<div class="row" style="padding-top: 60px">
    <div class="container center-block">
        <div class="col-md-1"></div>
        <div class="col-md-10 col-sm-12">
            <div class="ds-thread"
                 data-thread-key=6430fe0ae14977565a6f7214
                 data-title=MPP Pipeline VS Grouped Execution VS Stage By Stage
                 data-url=mpp-grouped-excution-stage>
            </div>
        </div>
        <div class="col-md-1"></div>
    </div>
</div>

<div class="footer">
    <a href="https://www.bcmeng.com/" target="_blank"  rel="nofollow">康凯森</a>
</div>

<script src="../js/code.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../js/jquery.min.js"></script>
<script src="../js/bootstrap.js"></script>
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?1d198a377ef466190881d1c021155925";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
</body>
</html>